
package # hide the package from PAUSE
    InsideOutClass::Instance;

use strict;
use warnings;

our $VERSION = '0.06';

use Carp         'confess';
use Scalar::Util 'refaddr';

use base 'Class::MOP::Instance';

sub create_instance {
	my ($self, $class) = @_;
    $self->bless_instance_structure(\(my $instance));
}

sub get_slot_value {
	my ($self, $instance, $slot_name) = @_;
	$self->{meta}->get_package_variable('%' . $slot_name)->{refaddr $instance};
}

sub set_slot_value {
	my ($self, $instance, $slot_name, $value) = @_;
	$self->{meta}->get_package_variable('%' . $slot_name)->{refaddr $instance} = $value;
}

sub initialize_slot {
    my ($self, $instance, $slot_name) = @_;
    $self->{meta}->add_package_variable(('%' . $slot_name) => {})
        unless $self->{meta}->has_package_variable('%' . $slot_name); 
    $self->{meta}->get_package_variable('%' . $slot_name)->{refaddr $instance} = undef;
}

sub is_slot_initialized {
	my ($self, $instance, $slot_name) = @_;
	return 0 unless $self->{meta}->has_package_variable('%' . $slot_name);
	return exists $self->{meta}->get_package_variable('%' . $slot_name)->{refaddr $instance} ? 1 : 0;
}

## &remove_slot is left as an exercise for the reader :)

1;

__END__

=pod

=head1 NAME

InsideOutClass - A set of example metaclasses which implement the Inside-Out technique

=head1 SYNOPSIS

  package Foo;
  
  use metaclass 'Class::MOP::Class' => (
     # tell our metaclass to use the 
     # InsideOut attribute metclass 
     # to construct all it's attributes
    ':instance_metaclass' => 'InsideOutClass::Instance'
  );
  
  __PACKAGE__->meta->add_attribute('foo' => (
      reader => 'get_foo',
      writer => 'set_foo'
  ));    
  
  sub new  {
      my $class = shift;
      $class->meta->new_object(@_);
  } 

  # now you can just use the class as normal

=head1 DESCRIPTION

This is a set of example metaclasses which implement the Inside-Out 
class technique. What follows is a brief explaination of the code 
found in this module.

We must create a subclass of B<Class::MOP::Instance> and override 
the slot operations. This requires 
overloading C<get_slot_value>, C<set_slot_value>, C<slot_initialized>, and
C<initialize_slot>, as well as their inline counterparts. Additionally we
overload C<add_slot> in order to initialize the global hash containing the
actual slot values.

And that is pretty much all. Of course I am ignoring need for 
inside-out objects to be C<DESTROY>-ed, and some other details as 
well (threading, etc), but this is an example. A real implementation is left as
an exercise to the reader.

=head1 AUTHOR

Stevan Little E<lt>stevan@iinteractive.comE<gt>

=head1 SEE ALSO

L<Tie::RefHash::Weak>

=head1 COPYRIGHT AND LICENSE

Copyright 2006 by Infinity Interactive, Inc.

L<http://www.iinteractive.com>

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. 

=cut
